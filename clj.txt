	(= true true)

  "To understand reality, we must compare our expectations against reality"
  (= 2 (+ 1 1))

  "You can test equality of many things"
  (= (+ 3 4) 7 (+ 2 5))

  "Some things may appear different, but be the same"
  (= true (= 2 2/1))

  "You cannot generally float to heavens of integers"
  (= false (= 2 2.0))

  "But a looser equality is also possible"
  (= true (== 2.0 2))

  "Something is not equal to nothing"
  (= true (not (= 1 nil)))

  "Strings, and keywords, and symbols: oh my!"
  (= false (= "hello" :hello 'hello))

  "Make a keyword with your keyboard"
  (= :hello (keyword "hello"))

  "Symbolism is all around us"
  (= 'hello (symbol "hello"))

  "What could be equivalent to nothing?"
  (= nil nil)

  "When things cannot be equal, they must be different"
  (not= :fill-in-the-blank 'fill-in-the-blank))

2

(meditations
  "A string is nothing more than text surrounded by double quotes"
  (= "hello" "hello")

  "But double quotes are just magic on top of something deeper"
  (= "world" (str 'world))

  "You can do more than create strings, you can put them together"
  (= "Cool right?" (str "Cool" " " "right?"))

  "You can even get certain characters"
  (= \C (get "Characters" 0))

  "Or even count the characters"
  (= 11 (count "Hello World"))

  "But strings and characters are not the same"
  (= false (= \c "c"))

  "What if you only wanted to get part of a string?"
  (= "World" (subs "Hello World" 6 11))

  "How about joining together elements in a list?"
  (= "123" (closure.string/join '(1 2 3)))

  "What if you wanted to separate them out?"
  (= "1, 2, 3" (clojure.string/join ", " '(1 2 3)))

  "Maybe you want to separate out all your lines"
  (= ["1" "2" "3"] (clojure.string/split-lines "1\n2\n3"))

  "You may want to make sure your words are backwards"
  (= "olleh" (string/reverse "hello"))

  "Maybe you want to find the index of the first occurrence of a substring"
  (= 0 (string/index-of "hello world" "h"))

  "Or maybe the last index of the same"
  (= 13 (string/last-index-of "hello world, hello" "hello"))

  "But when something doesn't exist, nothing is found"
  (= nil (string/index-of "hello world" "bob"))

  "Sometimes you don't want whitespace cluttering the front and back"
  (= "hello world" (string/trim "  \nhello world \t \n"))

  "You can check if something is a char"
  (= true (char? \c))

  "But it may not be"
  (= false (char? "a"))

  "But chars aren't strings"
  (= false (string? \b))

  "Strings are strings"
  (= true (string? "string"))

  "Some strings may be blank"
  (= true (clojure.string/blank? ""))

  "Even if at first glance they aren't"
  (= true (clojure.string/blank? " \n \t  "))

  "However, most strings aren't blank"
  (= false (string/blank? "hello?\nare you out there?")))

3

(meditations
  "Lists can be expressed by function or a quoted form"
  (= '(1 2 3 4 5) (list 1 2 3 4 5))

  "They are Clojure seqs (sequences), so they allow access to the first"
  (= 1 (first '(1 2 3 4 5)))

  "As well as the rest"
  (= '(2 3 4 5) (rest '(1 2 3 4 5)))

  "Count your blessings"
  (= 3 (count '(dracula dooku chocula)))

  "Before they are gone"
  (= 0 (count '()))

  "The rest, when nothing is left, is empty"
  (= '() (rest '(100)))

  "Construction by adding an element to the front is easy"
  (= '(:a :b :c :d :e) (cons :a '(:b :c :d :e)))

  "Conjoining an element to a list isn't hard either"
  (= '(:a :b :c :d :e) (conj '(:a :b :c :d) :e))

  "You can use a list like a stack to get the first element"
  (= __ (peek '(:a :b :c :d :e)))

  "Or the others"
  (= __ (pop '(:a :b :c :d :e)))

  "But watch out if you try to pop nothing"
  (= __ (try
          (pop '())
          (catch IllegalStateException e
            "No dice!")))

  "The rest of nothing isn't so strict"
  (= __ (try
          (rest '())
          (catch IllegalStateException e
            "No dice!"))))